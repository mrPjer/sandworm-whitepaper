\documentclass[times, utf8, zavrsni]{fer}
\usepackage{booktabs,appendix,listings}

\begin{document}

\thesisnumber{4942}

\title{Sustav za sigurno i učinkovito udaljeno izvođenje studentskih programskih vježbi}

\author{Petar Šegina}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}

U redovnoj nastavi Fakulteta elektrotehnike i računarstva studenti se nerijetko susreću sa zadaćama čija je rješenja potrebno ostvariti pisanjem programa u odgovarajućim programskim jezicima. Ručno vrednovanje takvih rješenja bio bi dug i težak posao te se zato u sklopu određenih kolegija za vrednovanje rješenja koriste automatizirani sustavi.

Princip rada takvih sustava je jednostavan - svaki student svoje rješenje piše po specifikaciji koja zahtijeva da program sa standardnog ulaza učita ulazne podatke te na standardni izlaz ispiše rješenje izvođenja u nekom strukturiranom zapisu. Sve što sustav za evaluaciju mora poznavati da bi dobro odradio svoj posao je jedan ili više parova ulaza i očekivanog izlaza. Algoritam sustava za izvršavanje može se zatim svesti na slijedeće:

\begin{enumerate}
\item Prevedi izvorni kod u izvršni oblik
\item Pokreni program
\item Na standardni ulaz programa proslijedi ulazne podatke
\item Čekaj kraj programa
\item Sakupi izlaz programa
\item Usporedi dobiveni izlaz sa očekivanim i javi rezultat
\end{enumerate}

Iako se taj posao na prvi pogled čini jednostavnim, iza navedenih koraka skriva se mnogo izazova od kojih su neki:

\begin{enumerate}
\item Kako prevesti kod u izvršni oblik?
	\begin{itemize}
	\item Koje programske jezike i okruženja podržati?
	\item Koje inačice programskih jezika i okruženja podržati?
	\item Kako ostvariti podršku za više sličnih izvršnih okolina na jednom sustavu?
	\item Što ako se program ne uspije uspješno prevesti?
	\end{itemize}
\item Kako sigurno i uspješno izvršiti program?
	\begin{itemize}
	\item Što ako program sadrži grešku i neće nikada završiti?
	\item Što ako je program maliciozan i pokuša naškoditi izvršnoj okolini?
	\end{itemize}
\item Kako vrednovati dodatna svojstva rješenja?
	\begin{itemize}
	\item Možemo li prihvatiti samo rješenja koja izvršavanje završe u određenom vremenu?
	\item Možemo li prihvatiti samo rješenja koja koriste određenu količinu memorije?
	\end{itemize}
\end{enumerate}

Uz sve to, sustav za vrednovanje također mora biti efikasan. Primjera radi, ako kolegij upiše 600 studenata, od čega ih 500 preda rješenje laboratorijske vježbe te ako se vrednovanje te vježbe sastoji od 20 testnih primjera koji se u prosjeki svaki izvršava pet sekundi, za evaluaciju laboratorijske vježbe biti će potrebno 500*20*5 = 50.000 sekundi ili otprilike 14 sati, ako ispitivanje provodimo jedan po jedan primjer.

Idealan sustav za vrednovanje rješenja trebao bi biti brz, efikasan, siguran i lak za korištenje. U nastavku ćemo prvo promotriti par postojećih rješenja, a zatim opisati implementaciju vlastitog sustava temeljenog na tehnologiji {\textit{Docker}}. Ostvareni sustav temeljen je na svojstvu razmjernog rasta kako bi se izvršavanje moglo rasporediti na neograničen broj nezavisnih sustava. Također nudi i fleksibilnost po pitanju izvršnih okolina koje su podržane te je jednostavan za postaviti i koristiti.

% TODO neki hook zašto je ostvareni sustav kul

\chapter{Postojeći sustavi}

\section{SPRUT}

\section{CodeAssign}

\section{Judge0}

\chapter{Sustav za sigurno i učinkovito udaljeno izvođenje studentskih programskih vježbi}

\section{Korištene tehnologije}

Prije samog opisa ostvarenja sustava dajemo kratak pregled korištenih tehnologija kako bi olakšali praćenje i razumijevanje samog postupka implementacije.

\subsection{Docker}

Veoma pojednostavljeno, Docker je tehnologija koja nam omogućava da u jednu crnu kutiju, osim samih izvršnih datoteka, također upakiramo i cijelu okolinu (\textit{userspace operativnog sustava}) u kojoj se naš program izvršava. Posljedica toga je da, ako želimo pokrenuti program X na svome računalu ili poslužitelju (gdje X može biti jednostavna \textit{hello-world} aplikacija ili složeni mrežni sustav), ne moramo brinuti o tome u kojem je jeziku taj program pisan te koje sve ovisnosti i preduvjete moramo zadovoljiti prije pokretanja. Docker nam omogućava da svaki program apstrahiramo na crnu kutiju sa jasno definiranim ulazima i izlazima.

Docker sve više raste u popularnosti te je za očekivati da će postati \textit{de facto} standard za postavljanje i pokretanje programa i web usluga. Unutar svog projekta ga koristimo iz istog razloga - svi mikroservisi nude svoje Docker slike kako bi se cijeli sustav jednostavnije mogao postaviti i pokrenuti. No, također ga koristimo i za pojednostavljenu izgradnju i izvršavanje studentskih rješenja, o čemu će više riječi biti kasnije.

\subsection{Spring}

Naš sustav ostvarili smo u obliku više nezavisnih mikroservisa kako bi osigurali mogućnost razmjernog rasta. Mikroservise smo ostvarili u programskom okviru Spring jer je autor imao prijašnjeg iskustva s istim, a on nam je omogućio brz razvoj mikroservisa povezanih protokolom HTTP te brzu i jednostavnu implementaciju komunikacije s bazom podataka.

\subsection{Kotlin}

Kotlin je programski jezik koji se nedavno pojavio te je uzeo velikog maha u zajednici osoba koje razvijaju za platformu Android. Radi se o modernom programskom jeziku koji se (među ostalim) prevodi u Java bytekod te nudi potpunu interoperabilnost sa postojećim JVM tehnologijama.

Od prednosti nad programskim jezikom Java istaknuti ćemo sigurniji i bolji sustav tipova, jednostavniju i izražajniju sintaksu te bolju podršku za određene konstrukte funkcijskog programiranja.

Kotlin smo koristili za izradu svih mikroservisa i pomoćnih biblioteka. 

\subsection{H2}

Kako u nekom trenutku moramo spremiti rezultate vrednovanja, odlučili smo ih spremiti u relacijsku bazu podataka. Za tu komponentu smo odabrali bazu H2 jer korišteni programski okvir Spring Data ima odličnu podršku za istu. Također, H2 može svoje podatke spremati u običnu datoteku na datotečnom sustavu što nam pojednostavljuje proces postavljanja i održavanja baze podataka.

\section{Idejno ostvarenje}

Prije opisivanja ideje ostvarenja, podsjetimo se što očekujemo od sustava kojeg želimo napraviti, ali i koristiti:

\begin{enumerate}
\item
\end{enumerate}

Glavni alat na kojem ćemo bazirati svoje rješenje jesu izvršne Docker slike. Naime, Docker nam omogućava da bilo koji program upakiramo, zajedno s njegovom izvršnom okolinom, u crnu kutiju koju zatim možemo izvršiti poput izvršne datoteke. Sve što nam je pritom potrebno je Docker okolina te ne ovisimo o implementacijskim detaljima programa kojeg izvršavamo. Izvršne Docker slike možemo pojednostavljeno smatrati kako statično povezivanje na steroidima - u kutiji uz program dolazi i cijeli \textit{userspace} operativnog sustava nad kojim će se program izvršiti.

Iduća veoma korisna činjenica je ta da u samu Docker sliku možemo \textit{upeći} ulazne podatke koje će program primiti. Tako ćemo dobiti izvršnu Docker sliku koja će za deterministički program uvijek davati jednak izlaz, neovisno o tome gdje je pokrenuta, a možemo ju pokrenuti bilo gdje gdje imamo pristup Dockeru.

Prije nego što možemo rješenje izvršiti, moramo prilikom generiranja Docker slike ponuditi ili izvršnu okolinu za interpretirane jezike ili prevedene datoteke za jezike koji se prevode. Ovaj korak je individualan za svaki jezik, a detalje ćemo ponuditi nešto kasnije.

Zadnja stvar koja će nas zanimati je kako je tekao proces prevođenja i izvršavanja samog programa te koji je njegov konačni ispis. Prilikom izvršavanja izvršne Docker slike, standardni izlaz programa biti će vidljiv na ekranu. No, kako bi mogli automatizirati evaluaciju te obrađivati izlaz, morat ćemo ga proslijediti na udaljenu lokaciju. To možemo ostvariti na način da prilikom izvršavanja sam program omotamo u drugi program koji će uhvatiti njegov izlaz i proslijediti ga na odgovarajuću lokaciju. No, kako želimo zadržati fleksibilnost, cilj nam je udaljenu lokaciju na koju će se slati informacije o izvršavanju na neki način parametrizirati. Izvršne Docker slike nam i to omogućuju te možemo prilikom izvršavanja slike također predati i dodatne argumente, što ćemo iskoristiti za parametriziranje udaljene lokacije na koju će se slati informacije o izvršavanju.

Uzimanjem svega navedenog u obzir, koristeći izvršne Docker slike možemo dobiti \textit{nešto} koje će svojim pokretanjem rezultate izvršavanja programa poslati na neku udaljenu lokaciju. Idealni poziv takve slike bio bi:

\begin{lstlisting}
./nesto https://mojaudaljenalokacija
\end{lstlisting}

dok će u stvarnosti izgledati ovako:

\begin{lstlisting}[language=Bash]
docker run --rm -it \
	sandworm/images/test_image/compiled/hello_petar \
	https://sandworm-logger/neki-tag
\end{lstlisting}

Rezultat ovog pristupa je taj da nam nije bitno gdje se izvršavanje događa te kamo se usmjerava rezultat izvršavanja. To nam omogućava da veoma lako ostvarimo svojstvo razmjernog rasta - radilica koje će izvršavati programe možemo imati proizvoljno mnogo, a isto to možemo napraviti i sa servisima koji će skupljati informacije o izvršavanju. Ono što će nam još trebati je servis ili alat koji će se brinuti o zakazivanju izvršavanja - na kojoj će se radilici izvesti koja slika te kamo će ona proslijediti rezultat izvođenja.

Konačno, cijeli proces vrednovanja možemo opisati slijedećim koracima:

\begin{enumerate}
\item Za svaki par (program, ulazna definicija) generirati izvršnu Docker sliku sa potpuno fiksiranim kontekstom izvršavanja
\item Pokrenuti sliku na radilici sa Docker podrškom
\item Pokupiti informacije o izvršavanju i vrednovati rezultat
\end{enumerate}

\section{Logička arhitektura}

\section{Ostvarenje}

\subsection{Bazne slike s izvršnim okolinama za pojedine jezike}

\subsection{Alat za pakiranje rješenja i ulaznih definicija u izvršne Docker slike}

\subsection{Praćenje i dijeljenje rezultata izvođenja}

\subsection{Servis za prikupljanje i skladištenje rezultata}

\subsection{Servis za zakazivanje izvođenja i upravljanje radilicama}

\chapter{Vrednovanje}

\chapter{Zaključak}
Zaključak.

\begin{appendices}

\chapter{Upute za postavljanje}

\section{Preuzimanje izvornog koda}

\section{Pokretanje okoline uz pomoć alata Docker}

\section{Pokretanje okoline uz pomoć alata Gradle}

\chapter{Upute za korištenje}

\section{Dodavanje podrške za nova izvršna okruženja}

\section{Priprema izvornih datoteka za izvođenje}

\section{Zakazivanje izvršavanja}

\section{Dohvat rezultata izvršavanja}

\end{appendices}

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

\engtitle{Secure and Scalable Remote Execution of Students' Programming Assignments}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}
