\documentclass[times, utf8, zavrsni]{fer}
\usepackage{booktabs,appendix,listings,hyperref,graphicx,float,courier,dirtree,pdfpages}
\graphicspath{ {img/} }

\begin{document}

\thesisnumber{4942}

\title{Sustav za sigurno i učinkovito udaljeno izvođenje studentskih programskih vježbi}

\author{Petar Šegina}

\maketitle

\includepdf[pages=-,width=\paperwidth]{final_task.pdf}

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents

\chapter{Uvod}

U redovnoj nastavi Fakulteta elektrotehnike i računarstva studenti se nerijetko susreću sa zadaćama čija je rješenja potrebno ostvariti pisanjem programa u odgovarajućim programskim jezicima. Ručno vrednovanje takvih rješenja bio bi dug i težak posao te se zato u sklopu određenih kolegija za vrednovanje rješenja koriste automatizirani sustavi.

Princip rada takvih sustava je jednostavan - svaki student svoje rješenje piše po specifikaciji koja zahtijeva da program sa standardnog ulaza učita ulazne podatke te na standardni izlaz ispiše rješenje izvođenja u nekom strukturiranom zapisu. Sve što sustav za evaluaciju mora poznavati da bi dobro odradio svoj posao je jedan ili više parova ulaza i očekivanog izlaza. Algoritam sustava za izvršavanje može se zatim svesti na sljedeće:

\begin{enumerate}
\item Prevedi izvorni kod u izvršni oblik
\item Pokreni program
\item Na standardni ulaz programa proslijedi ulazne podatke
\item Čekaj kraj programa
\item Sakupi izlaz programa
\item Usporedi dobiveni izlaz s očekivanim i javi rezultat
\end{enumerate}

Iako se taj posao na prvi pogled čini jednostavnim, iza navedenih koraka skriva se mnogo izazova od kojih su neki:

\begin{enumerate}
\item Kako prevesti kod u izvršni oblik?
	\begin{itemize}
	\item Koje programske jezike i okruženja podržati?
	\item Koje inačice programskih jezika i okruženja podržati?
	\item Kako ostvariti potporu za više sličnih izvršnih okolina na jednom sustavu?
	\item Što ako se program ne uspije uspješno prevesti?
	\end{itemize}
\item Kako sigurno i uspješno izvršiti program?
	\begin{itemize}
	\item Što ako program sadrži grešku i neće nikada završiti?
	\item Što ako je program maliciozan i pokuša naškoditi izvršnoj okolini?
	\end{itemize}
\item Kako vrednovati dodatna svojstva rješenja?
	\begin{itemize}
	\item Možemo li prihvatiti samo rješenja koja izvršavanje završe u određenom vremenu?
	\item Možemo li prihvatiti samo rješenja koja koriste određenu količinu memorije?
	\end{itemize}
\end{enumerate}

Uz sve to, sustav za vrednovanje također mora biti učinkovit. Primjera radi, ako kolegij upiše 600 studenata, od čega ih 500 preda rješenje laboratorijske vježbe te ako se vrednovanje te vježbe sastoji od 20 testnih primjera koji se u prosjeku svaki izvršava pet sekundi, za evaluaciju laboratorijske vježbe bit će potrebno 500*20*5 = 50.000 sekundi ili otprilike 14 sati, ako ispitivanje provodimo jedan po jedan primjer.

Idealan sustav za vrednovanje rješenja trebao bi biti brz, učinkovit, siguran i lak za korištenje. U nastavku ćemo prvo promotriti par postojećih rješenja, a zatim opisati ostvarenje vlastitog sustava temeljenog na tehnologiji {\textit{Docker}}. Ostvareni sustav temeljen je na svojstvu razmjernog rasta kako bi se izvršavanje moglo rasporediti na veći broj nezavisnih sustava. Također nudi i fleksibilnost po pitanju izvršnih okolina koje su podržane te je jednostavan za postaviti i koristiti.

\chapter{Postojeći sustavi}

Za početak, dan je osvrt na nekoliko postojećih sustava za izvršavanje i evaluaciju programskih rješenja. Sustavi su navedeni dijelom jer su poslužili kao inspiracija u razvoju našeg rješenja zbog svojih inovativnih pristupa, a dijelom jer su valjane alternative koje treba razmotriti i uzeti u obzir prilikom odabira sustava za vrednovanje.

\section{SPRUT}

SPRUT{\footnote{\url{https://balrog.zemris.fer.hr/}}} je sustav za vrednovanje studentskih vježbi koji se koristi za automatsko vrednovanje studentskih laboratorijskih vježbi na Fakultetu elektrotehnike i računarstva u sklopu kolegija poput {\textit{Uvod u teoriju računarstva (86537)}}{\footnote{\url{https://www.fer.unizg.hr/predmet/utrz}}} te {\textit{Prevođenje programskih jezika (86504)}}{\footnote{\url{https://www.fer.unizg.hr/predmet/ppj_a}}}.

Iako SPRUT trenutno zadovoljava potrebe na navedenim kolegijima, mana mu je sekvencijalno izvođenje i nemogućnost razmjernog rasta, zbog čega vrednovanje studentskih vježbi traje dugo te je jedina mogućnost za optimizaciju {\textit{vertikalni}} rast, tj. kupovina bržeg hardvera.

\section{CodeAssign}

CodeAssign{\footnote{\url{https://codeassign.com/}}} je sustav nastao kao studentski projekt u sklopu kolegija {\textit{Oblikovanje programske potpore (34269)}}{\footnote{\url{https://www.fer.unizg.hr/predmet/opp}}}. CodeAssign je zamišljen kao mjesto gdje studenti, profesori i svi ostali zainteresirani mogu dijeliti programske zadatke i vježbe čija se rješenja automatizirano vrednuju.

Ono što CodeAssign razlikuje od ostalih rješenja je to što se sve izvršavanje koda događa na klijentu, dok poslužitelj samo potvrđuje valjanost dobivenog izlaza. Prednost takvog pristupa je znatno jednostavnija arhitektura poslužitelja, koji samo mora uspoređivati dobiveni izlaz s očekivanim te puno veća fleksibilnost na klijentu - korisnik sam odabire programsku okolinu u kojoj će raditi te se sam mora pobrinuti da ista radi.

Kako CodeAssign ne dolazi u dodir s izvornim kodom rješenja niti izvršava sam program, nije prikladan za vrednovanje laboratorijskih vježbi jer ne može potvrditi valjanost programskog rješenja. S druge strane, zbog lakoće korištenja i održavanja te fleksibilnosti u odabiru programske okoline smatramo ga dobrim odabirom za jednostavnije vježbe čija je svrha utvrđivanje i lakše praćenje gradiva.

CodeAssign je većinskim dijelom otvorenog koda{\footnote{\url{https://github.com/codeassign}}} te se samo ostvarenje može koristiti i u obrazovne svrhe.

\section{Judge0}

Judge0{\footnote{\url{http://judge0.com/}}} je javno dostupan sustav otvorenog koda{\footnote{\url{https://github.com/judge0}}} koji nudi uslugu sigurnog izvršavanja potencijalno malicioznog izvornog koda.

Prednost Judge0 je u tome što sustav nudi jednostavno programsko sučelje kojim se mogu zakazati izvođenja programa, dok mu je mana to što nije namijenjen razmjernom rastu te također obrađuje zadatke sekvencijalno. 

\section{Evaluator}

Evaluator{\footnote{\url{https://evaluator.mioc.hr/}}} je sustav koji se koristi u redovnoj nastavi zagrebačke XV. gimnazije te u sklopu vještine {\textit{Natjecateljsko programiranje (65973)}}{\footnote{\url{https://www.fer.unizg.hr/predmet/natpro}}} na Fakultetu elektrotehnike i računarstva.

Kako se redovno koristi u nastavi, Evaluator je postao robustan i stabilan sustav s potporom za različitim izvršnim okolinama te naprednim mogućnostima poput razmjernog rasta dodavanjem novih radilica te preciznog definiranja ograničenja na vrijeme izvođenja.

Mana Evaluatora je u tome što se radi o zatvorenom sustavu kojeg nije moguće jednostavno preuzeti i prilagoditi vlastitim potrebama.

\chapter{Sustav za sigurno i učinkovito udaljeno izvođenje studentskih programskih vježbi}

\section{Korištene tehnologije}

Prije samog opisa ostvarenja sustava dan je kratak pregled korištenih tehnologija kako bi bilo olakšano praćenje i razumijevanje samog postupka ostvarenja.

\subsection{Docker}

Veoma pojednostavljeno, Docker{\footnote{\url{https://www.docker.com/}}} je tehnologija koja omogućava da u jednu crnu kutiju, osim samih izvršnih datoteka, također bude upakirana i cijela okolina (\textit{userspace} operativnog sustava) u kojoj se program izvršava. Posljedica toga je da prilikom pokretanja programa X na računalu ili poslužitelju (gdje X može biti jednostavna \textit{hello-world} aplikacija ili složeni mrežni sustav), nije potrebno brinuti o tome u kojem je jeziku taj program pisan te koje je sve ovisnosti i preduvjete potrebno zadovoljiti prije pokretanja. Docker omogućava da svaki program bude apstrahiran na crnu kutiju s jasno definiranim ulazima i izlazima.

Docker sve više raste u popularnosti te je za očekivati da će postati \textit{de facto} standard za postavljanje i pokretanje programa i web usluga. Unutar ovog projekta je korišten iz istog razloga - svi mikroservisi nude svoje Docker slike kako bi se cijeli sustav jednostavnije mogao postaviti i pokrenuti. No, također je korišten i za pojednostavljenu izgradnju i izvršavanje studentskih rješenja, o čemu će više riječi biti kasnije.

\subsection{Spring}

Sustav koji će biti opisan ostvaren je u obliku više nezavisnih mikroservisa kako bi bila osigurana mogućnost razmjernog rasta. Mikroservisi su ostvareni u programskom okviru Spring{\footnote{\url{https://spring.io/}}} jer je autor imao prijašnjeg iskustva s istim, a on je omogućio brz razvoj mikroservisa povezanih protokolom HTTP te brzo i jednostavno ostvarenje komunikacije s bazom podataka.

\subsection{Kotlin}

Kotlin{\footnote{\url{https://kotlinlang.org/}}} je programski jezik koji se nedavno pojavio te je uzeo velikog maha u zajednici osoba koje razvijaju programska rješenja za platformu Android. Radi se o modernom programskom jeziku koji se (među ostalim) prevodi u Java bytekod te nudi potpuno međudjelovanje s postojećim JVM tehnologijama.

Od prednosti nad programskim jezikom Java istaknut je sigurniji i bolji sustav tipova, jednostavnija i izražajnija sintaksa te bolja potporu za određene konstrukte funkcijskog programiranja.

Kotlin je korišten za izradu svih mikroservisa i pomoćnih biblioteka. 

\subsection{H2}

Kako je u nekom trenutku nužno spremiti rezultate vrednovanja, odlučeno je spremiti ih u relacijsku bazu podataka. Za tu komponentu je odabrana baza H2{\footnote{\url{http://www.h2database.com/html/main.html}}} jer korišteni programski okvir Spring Data ima odličnu potporu za istu. Također, H2 može svoje podatke spremati u običnu datoteku na datotečnom sustavu što pojednostavljuje proces postavljanja i održavanja baze podataka.

\section{Idejno ostvarenje}

Od sustava kojeg želimo napraviti, ali i koristiti, očekujemo:

\begin{enumerate}
\item Sigurnost
\item Mogućnost razmjernog rasta (\textit{skalabilnost})
\item Učinkovitost
\item Jednostavnost korištenja
\end{enumerate}

Glavni alat na kojem će rješenje biti zasnovano jesu izvršne Docker slike. Docker omogućava da bilo koji program bude upakiran, zajedno s njegovom izvršnom okolinom, u crnu kutiju koja se zatim može izvršiti poput izvršne datoteke. Sve što je pritom potrebno je Docker okolina te se ne ovisi o implementacijskim detaljima programa koji se izvršava. Izvršne Docker slike mogu se pojednostavljeno smatrati kao statično povezivanje na steroidima - u kutiji uz program dolazi i cijeli \textit{userspace} operativnog sustava nad kojim će se program izvršiti.

Iduća veoma korisna činjenica je ta da se u samu Docker sliku mogu \textit{upeći} ulazni podaci koje će program primiti. Tako se dobiva izvršna Docker sliku koja će za deterministički program uvijek davati jednak izlaz, neovisno o tome gdje je pokrenuta, a može se pokrenuti bilo gdje, gdje postoji pristup Dockeru.

Prije nego što se rješenje može izvršiti, nužno je prilikom generiranja Docker slike ponuditi ili izvršnu okolinu za interpretirane jezike ili prevedene datoteke za jezike koji se prevode. Ovaj korak je individualan za svaki jezik, a detalji će biti ponuđeni nešto kasnije.

Zadnja stvar koja će biti korisna je informacija kako je tekao proces prevođenja i izvršavanja samog programa te koji je njegov konačni ispis. Prilikom izvršavanja izvršne Docker slike, standardni izlaz programa bit će vidljiv na ekranu. No, kako bi se mogla automatizirati evaluacija te obrađivati izlaz, potrebno ga je proslijediti na udaljenu lokaciju. To je moguće ostvariti tako da prilikom izvršavanja sam program bude omotan u drugi program koji će uhvatiti njegov izlaz i proslijediti ga na odgovarajuću lokaciju. No, kako je poželjno zadržati fleksibilnost, cilj je udaljenu lokaciju na koju će se slati informacije o izvršavanju na neki način parametrizirati. Izvršne Docker slike i to omogućuju te je moguće prilikom izvršavanja slike također predati i dodatne argumente, što će biti iskorišteno za parametriziranje udaljene lokacije na koju će se slati informacije o izvršavanju.

Uzimanjem svega navedenog u obzir, koristeći izvršne Docker slike moguće je dobiti \textit{nešto} što će svojim pokretanjem rezultate izvršavanja programa poslati na neku udaljenu lokaciju. Idealni poziv takve slike bio bi:

\begin{lstlisting}
./nesto https://mojaudaljenalokacija
\end{lstlisting}

što bi unutar sebe pokrenulo program koji se vrednuje i informacije o toku izvršavanja poslalo na udaljeno web sjedište {\textit{mojaudaljenalokacija}}. U stvarnosti će taj poziv izgledati ovako:

\begin{lstlisting}[language=Bash]
docker run --rm \
	sandworm/images/test_image/compiled/hello_petar \
	https://sandworm-logger/neki-tag
\end{lstlisting}

što će pokrenuti Docker sliku kreiranu za navedeni program i proslijediti pokretaču unutar nje lokaciju na koju treba poslati informacije o izvršavanju.

Rezultat ovog pristupa je taj da nije bitno gdje se izvršavanje događa te kamo se usmjerava rezultat izvršavanja. To omogućava da se veoma lako ostvari svojstvo razmjernog rasta - radilica koje će izvršavati programe može biti proizvoljno mnogo, a isto to se može napraviti i sa servisima koji će skupljati informacije o izvršavanju. Ono što će još trebati je servis ili alat koji će se brinuti o zakazivanju izvršavanja - na kojoj će se radilici izvesti koja slika te kamo će ona proslijediti rezultat izvođenja.

Konačno, cijeli proces vrednovanja može se opisati sljedećim koracima:

\begin{enumerate}
\item Za svaki par (program, ulazna definicija) generirati izvršnu Docker sliku s potpuno fiksiranim kontekstom izvršavanja
\item Pokrenuti sliku na nekoj radilici s Docker potporom - samo pokretanje će slati informacije o izvršavanju na udaljenu lokaciju
\item Preuzeti rezultate izvršavanja s nekog servisa za praćenje izvršavanja
\end{enumerate}

Dodatno, ako prilikom pokretanja nije navedena udaljena lokaciju na koju će se slati informacije o izvršavanju, program se pokreće bez funkcionalnosti skupljanja podataka. Time je dobivena crna kutija koja, jednom kad se pokrene, izvrši korisnički program s jednim točno definiranim skupom podataka. Korisna posljedica je ta da je dobiven jednostavan način reprodukcije rezultata pokretanja koji ne ovisi o platformi na kojoj se program pokreće. Tako, ako student nije zadovoljan rezultatom vrednovanja svog programa, može pokrenuti generiranu sliku lokalno i uvjeriti se u ispis svog programa.

Konkretan sustav ostvaren je kao skup nezavisnih alata i mikroservisa koji obavljaju navedene zadaće, a detaljnije će biti opisani u nastavku.

\section{Logička arhitektura}

Kao što je već navedeno, sam sustav ostvaren je kao skup nezavisnih alata i mikroservisa. Logička arhitektura koja prikazuje način na koji su manje jedinice spojene u funkcionalnu cjelinu prikazan je u nastavku.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{sandworm-schema.png}
	\caption{Prikaz logičke arhitekture sustava}
\end{figure}

Alati s kojima korisnik dolazi u susret su usluga za pakiranje ulaznih podataka i izvršnog koda u izvršne Docker slike, {\textit{sandworm-packer-web}}, usluga za zakazivanje i izvršavanje kreiranih slika, {\textit{sandworm-scheduler}} te usluga za prikupljanje i skladištenje rezultata, {\textit{sandworm-logger}}.

\hfill
\break

Zamišljena interakcija korisnika (fizičkog ili drugog programa) je sljedeća:

\begin{enumerate}
\item Na uslugu za pakiranje korisnik šalje ulaznu definiciju programa kojeg vrednuje - naziv izvršne okoline, izvorni kod, skup ulaznih datoteka, lokaciju zapisivanja rezultata postupka pakiranja te proizvoljan naziv pod kojim će biti spremljene informacije o pakiranju te na temelju kojeg će biti generirani nazivi Docker slika. Jednom kada poziv završi, u dijeljenom registru Docker slika ({\textit{Docker registry}}) nalazit će se slike za svaki ulazni podatak te jedna slika bez ulaznih podataka, ali s prevedenim programom.
\item Na uslugu za zakazivanje izvođenja korisnik za svaku generiranu sliku šalje novi zahtjev u kojem definira putanju do dijeljenog registra, naziv slike te putanju do usluge za prikupljanje i skladištenje rezultata. Usluga će zatim zakazati izvršavanje na jednoj od radilica ({\textit{worker \#n}}) te informaciju o tome poslati na uslugu za prikupljanje i skladištenje rezultata. Jednom kada izvršavanje završi, u toj istoj usluzi će se nalaziti i informacija o tijeku izvođenja te prikupljeni standardni izlaz programa.
\item Korisnik na temelju naziva kojeg je zadao u prvom koraku s usluge za prikupljanje i skladištenje rezultata povlači informacije o tijeku pakiranja, prevođenja i izvršavanja.
\end{enumerate}

Usluga za pakiranje rješenja i ulaznih definicija ({\textit{sandworm-packer-web}}) ostvarena je kao jednostavan omotač oko biblioteke za pakiranje rješenja i ulaznih definicija ({\textit{sandworm-packer}}) koja je ostvarena kao zaseban alat kojeg možemo koristiti iz komandne linije te ju zato posebno ističemo na shemi logičke arhitekture.


\section{Ostvarenje}
\label{sec:implementation}

Projekt je, sukladno logičkoj arhitekturi, podijeljen na odgovarajuće potprojekte. Oni su:

\begin{enumerate}
\item {\textit{sandworm-images}} - temeljne Docker slike potrebne za izgradnju izvršnih Docker slika s potporom za razne izvršne okoline
\item {\textit{sandworm-packer}} - biblioteka i komandnolinijski alat za pakiranje ulaznih definicija u izvršne Docker slike
\item {\textit{sandworm-packer-web}} - web usluga za pristup funkcionalnosti alata za pakiranje
\item {\textit{sandworm-scheduler}} - usluga za zakazivanje izvođenja i upravljanje radilicama
\item {\textit{sandworm-logger}} - usluga za prikupljanje i skladištenje rezultata
\item {\textit{sandworm-whitepaper}} - izvorne datoteke ovog rada
\end{enumerate}


\subsection{Temeljne slike s izvršnim okolinama za pojedine jezike}

Kako bi sustav mogao podržati različite okoline izvršavanja bilo je potrebno napraviti nekoliko temeljnih Docker slika nad kojima će se graditi konačne izvršne slike. Točnije, za svaku željenu okolinu (npr. C, C++, JavaScript) potrebno je napraviti zasebnu sliku. Iako je bilo moguće napraviti jednu sliku koja bi sadržavala sve okoline, ovaj je pristup odabran zbog veće fleksibilnosti. Pojedine slike su veoma jednostavne i lakše za održavati u odnosu na jednu veliku sliku.

Svaka slika u svojem direktoriju sadrži skriptu {\textit{build.sh}} kojom se slika može izgraditi i koja označava sliku odgovarajućom oznakom. U vršnom direktoriju potprojekta nalazi se skripta {\textit{build.sh}} koja gradi sve pojedinačne slike.

\subsubsection{Temeljna slika}

Temeljna slika ({\textit{base}}) sadrži skripte koje nude osnovne funkcionalnosti sustava zajedničke svim okolinama. One su:

\begin{enumerate}
\item {\textit{compile.sh}} - skripta koja izvodi prevađanje izvornog koda u strojni kod za okoline u kojima je to potrebno
\item {\textit{stream-collector.sh}} - skripta koja šalje proizvoljan ispis na uslugu za prikupljanje i skladištenje rezultata
\item {\textit{entrypoint.sh}} - skripta koja omata skriptu {\textit{runner.sh}} i pomoću {\textit{stream-collector.sh}} šalje njen izlaz i izlaz za greške na uslugu za prikupljanje i skladištenje rezultata, definiranu kao prvi argument skripte
\end{enumerate}

Iako {\textit{entrypoint.sh}} poziva skriptu {\textit{runner.sh}}, ona nije dio temeljne slike. Naprotiv, nju će ponuditi slike specifične za svaku okolinu, jer ona određuje kako se program izvršava i kako mu se predaju ulazni podaci.

Sama definicija temeljne slike dostupna u datoteci {\textit{Dockerfile}} veoma je jednostavna:

\begin{lstlisting}
FROM ubuntu:16.04

RUN apt-get update \
    && apt-get install -y --no-install-recommends curl \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

COPY compile.sh .
COPY entrypoint.sh .
COPY stream-collector.sh .

ENTRYPOINT ["/bin/bash", "./entrypoint.sh"]
\end{lstlisting}

Slika prvo definira izvornu sliku za koju smo odabrali Ubuntu 16.04. Zatim u sebe kopira pomoćne skripte te na kraju definira skriptu {\textit{entrypoint.sh}} kao {\textit{entrypoint}} Docker slike, tj. skriptu koja će biti pokrenuta ako Docker sliku pokrenemo kao izvršni program.

Temeljna slika je sama po sebi beskorisna jer joj nedostaje ključna skripta {\textit{runner.sh}}. Ako pokušamo izgraditi i pokrenuti temeljnu skriptu, dobit ćemo grešku zbog skripte koja nedostaje. Da bi dobili izvršno okruženje koje radi moramo još definirati i instalaciju okruženja te način pozivanja programa.

\subsubsection{C i C++}

Idući korak je definiranje slika s izvršnim okruženjima te će se krenuti s okruženjem za programske jezike C i C++. Prvo će biti promatrana definicija slike u datoteci {\textit{Dockerfile}}:

\begin{lstlisting}
FROM sandworm/base/base

RUN apt-get update \
    && apt-get install -y --no-install-recommends build-essential \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

COPY runner.sh .
\end{lstlisting}

Za potporu za programske jezike C i C++ dovoljno je nad temeljnom slikom instalirati paket {\textit{build-essential}} (koji sadrži alate gcc i g++ potrebne za prevođenje koda) te ponuditi skriptu za pokretanje programa, {\textit{runner.sh}}. Njena definicija je:

\begin{lstlisting}
#!/usr/bin/env bash

./a.out
\end{lstlisting}

Sve što je potrebno za pokrenuti preveden program je pokrenuti izvršnu datoteku koja je generirana procesom prevođenja u skripti {\textit{compile.sh}} u temeljnoj slici, dok će se za preusmjeravanje ulaznih podataka te hvatanja izlaznih podataka pobrinuti omatajuća skripta {\textit{entrypoint.sh}}.

Zbog arhitekturalnih ograničenja je postupak prevođenja potrebno definirati u temeljnoj slici. 

Dodavanje potpore za nove okoline, kao što je vidljivo iz priloženog, vrlo je jednostavno.

\subsubsection{JavaScript}

Za razliku od jezika C i C++, programski jezik JavaScript je interpretirani jezik. No, to ne utječe pretjerano na količinu posla potrebnu za dodavanje potpore i za tu okolinu. Datoteka {\textit{Dockerfile}} prati sličnu strukturu kao i ona za jezike C i C++:

\begin{lstlisting}
FROM sandworm/base/base

RUN apt-get update \
    && apt-get install -y --no-install-recommends nodejs \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

COPY runner.sh .
\end{lstlisting}

Ovdje je umjesto paketa {\textit{build-essential}} instaliran paket {\textit{nodejs}} koji nudi izvršno okruženje za programski jezik JavaScript.

Konačno, potrebno je ponuditi i skriptu za pokretanje izvršavanja, {\textit{runner.sh}}:

\begin{lstlisting}
#!/usr/bin/env bash

nodejs main.js
\end{lstlisting}

Slično kao i prije, potrebno je pozvati izvršnu okolinu nad datotekom koja sadrži izvorni kod. Ovdje se ograničilo na to da rješenje mora imati datoteku naziva {\textit{main.js}} koja sadrži ulaznu točku u program. Ako je ovo potrebno promijeniti, dovoljno je doraditi ovu sliku, ili na temelju nje napraviti drugu.

\subsubsection{Ostali jezici}

U gornje dvije slike prikazan je postupak dodavanja potpore za jedan prevedeni i jedan interpretirani jezik. Kako dodavanje potpore za druge jezike prati istu šablonu, ostali neće biti ovdje navedeni, dok sam projekt sadrži još slike za programske jezike Python 2 i Python 3.

\subsection{Praćenje i dijeljenje rezultata izvođenja}

Da bi bilo moguće pratiti tijek izvođenja programa potrebno je informaciju o izvođenju negdje spremiti. Ovaj proces sastoji se od dvije komponente - s jedne strane postoji sustav koji nudi programsko sučelje za spremanje i arhiviranje informacija o izvođenju, dok s druge strane postoji sam proces izvođenja programa koji generira informacije koje treba spremiti.

Kako će se pratiti proces izvođenja programa? Ako se program izvodi lokalno, taj postupak je jednostavan - ispis programa bit će vidljiv u konzoli. No, kako je jedan od ciljeva mogućnost razmjernog rasta, nužno je odvojiti postupak izvođenja od postupka skladištenja rezultata izvođenja. Mogućnost preusmjeravanja ispisa programa na udaljeno računalo omogućuje da uistinu nije bitno gdje se i kako program izvodi.

Ideja iza ove funkcionalnosti je ta da se preusmjeri standardni izlaz i standardni izlaz za greške programa koji se izvodi na ulaz programa koji će sve što primi na svoj ulaz slati na udaljeni mrežni servis. Taj program za prosljeđivanje je konkretno skripta {\textit{stream-collector.sh}} dostupna u temeljnoj slici.

\begin{lstlisting}
LOGGER_ENDPOINT="$1"
LOGGER_TAG="$2"

while IFS= read -r line || [[ -n "$line" ]];
do
	if [ "$LOGGER_TAG" == "stderr" ]; then
		echo $line >&2;
	else
		echo $line;
	fi

	if [ ! -z "$LOGGER_ENDPOINT" ]; then
		curl \
			"$LOGGER_ENDPOINT" \
			--silent
			--data-urlencode "tag=$LOGGER_TAG" \
			--data-urlencode "content=$line" \
			--data-urlencode \
				"timestamp=`date --iso-8601=s`"
			> /dev/null
	fi
done
\end{lstlisting}

Skripta kao ulazne parametre prima lokaciju udaljenog odredišta na koje će slati ispis te oznaku pod kojom će spremiti taj ispis. Zatim, za svaku liniju svog ulaza prvo taj ulaz ispiše kako bi se moglo i u konzoli pratiti izvođenje. Zatim, ako je udaljeno odredište definirano, na njega se HTTP POST zahtjevom šalje informacije o ispisu i vremenu kada se taj ispis dogodio.

Ako udaljeno odredište nije definirano, skripta samo ispisuje ono što primi na svoj ulaz, što omogućava da se izvršna slika pokreće i lokalno, bez udaljenog praćenja ishoda.

Idući korak je omotati skriptu za izvođenje, {\textit{runner.sh}} tako da njeni izlazi budu preusmjereni u skriptu {\textit{stream-collector.sh}}. Ovo je ostvareno u ulaznoj skripti temeljne slike, {\textit{entrypoint.sh}}:

\begin{lstlisting}
LOGGER_ENDPOINT="\$1"

set -e;

touch ./stdin;

{ ./runner.sh 2>&1 1>&3 3>&- < ./stdin | \
	./stream-collector.sh "\$LOGGER_ENDPOINT" stderr; \
} 3>&1 1>&2 | ./stream-collector.sh "\$LOGGER_ENDPOINT" stdout;
\end{lstlisting}

Skripta osigurava postojanje datoteke {\textit{stdin}} te zatim poziva {\textit{runner.sh}}, prosljeđujući joj na standardni ulaz sadržaj datoteke {\textit{stdin}} te prosljeđujući njene izlaze{\footnote{\url{https://stackoverflow.com/a/31151808/576809}}} skripti {\textit{stream-collector.sh}}.

\subsection{Usluga za prikupljanje i skladištenje rezultata}

Drugi dio postupka praćenja izvođenja je mrežna usluga koja će prihvaćati informacije o izvođenju, skladištiti ih te omogućiti dohvat istih. U tu svrhu ostvaren je mikroservis naziva {\textit{sandworm-logger} koji preko HTTP programskog sučelja nudi upravo potrebnu funkcionalnost.

Sustav je implementiran u programskom okviru Spring s bibliotekama Spring Boot i Spring Data, dok same podatke sprema u relacijsku bazu podataka H2.

Samo ostvarenje usluge je uz potporu programskog okvira bilo jednostavno.

Prvo je definiran model podataka koji će biti spremani u bazu podataka:

\begin{lstlisting}
package hr.fer.zemris.sandworm.logger.model

import java.time.LocalDateTime
import javax.persistence.Entity
import javax.persistence.GeneratedValue
import javax.persistence.Id

@Entity
data class Message(
        @Id
        @GeneratedValue
        var id: Long?,

        var taskId: String,
        var tag: String,
        var content: String,
        var timestamp: LocalDateTime,
        var receivedAt: LocalDateTime
) {
    constructor() : this(
	 	null,
		"",
		"",
		"",
		LocalDateTime.MIN,
		LocalDateTime.MIN
	)
}
\end{lstlisting}

Kao jezik pisanja servisa odabran je Kotlin i na ovom primjeru je već vidljiva ekspresivnost jezika i prednost nad Javom. Kotlinov {\textit{Data Class}}{\footnote{\url{https://kotlinlang.org/docs/reference/data-classes.html}}} konstrukt omogućava da se entitet deklarativno opiše, dok će se sam jezik pobrinuti za ostvarenje gettera, settera, metoda {\textit{equals}}, {\textit{hashCode}} i {\textit{toString}}. Također je vidljivo i međudjelovanje s postojećim alatima - model je anotiran sa {\textit{javax.persistence.*}} anotacijama koje se mogu koristiti zbog Kotlinove potpune potpore za postojeći Java kod.


Nakon definicije modela definiran je jednostavan CRUD{\footnote{CRUD - {\textit{Create, Read, Update, Delete}}}} repozitorij:

\begin{lstlisting}
package hr.fer.zemris.sandworm.logger.repository

import hr.fer.zemris.sandworm.logger.model.Message
import org.springframework.data.repository.CrudRepository
import java.time.LocalDateTime

interface MessageRepository : CrudRepository<Message, Long> {

    fun findByTaskId(taskId: String): List<Message>

    fun findByTaskIdAndTimestampGreaterThan(
	 	taskId: String,
		timestamp: LocalDateTime
	 ): List<Message>

}
\end{lstlisting}

Ovakav repozitorij može se koristiti za komunikaciju s bazom podataka te omogućava unos, ispis i uređivanje informacija o porukama koje se primaju. Također su definirane i dvije pomoćne metode koje omogućavaju dohvat svih poruka vezanih za određen zadatak te dohvat tih poruka ograničen na one koje su se dogodile nakon određenog trenutka u vremenu.

U definiciji sustava dano je samo sučelje repozitorija - za konkretno ostvarenje pobrinut će se programski okvir Spring na temelju dane deklaracije.

Za kraj ostaje definirati krajnje točke mrežnog sučelja, što se u programskom okviru {\textit{Spring}} ostvaruje definicijom komponente zvane {\textit{Controller}}:

\begin{lstlisting}
package hr.fer.zemris.sandworm.logger.controller

import hr.fer.zemris.sandworm.logger.model.Message
import hr.fer.zemris.sandworm.logger.repository.MessageRepository
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.format.annotation.DateTimeFormat
import org.springframework.format.annotation.DateTimeFormat.ISO.DATE_TIME
import org.springframework.web.bind.annotation.*
import java.time.LocalDateTime

@RestController
class MainController
@Autowired constructor(
        val messageRepository: MessageRepository
) {

    @PostMapping("/{taskId}")
    fun logMessage(
            @PathVariable taskId: String,
            @RequestParam tag: String,
            @RequestParam content: String,
            @RequestParam @DateTimeFormat(iso = DATE_TIME)
				timestamp: LocalDateTime
    ) = messageRepository.save(Message(
            null,
            taskId,
            tag,
            content,
            timestamp,
            LocalDateTime.now()
    ))

    @GetMapping("/{taskId}")
    fun getMessages(@PathVariable taskId: String)
	 	= messageRepository.findByTaskId(taskId)

    @GetMapping("/{taskId}/since/{since}")
    fun getMessagesSince(
            @PathVariable taskId: String,
            @PathVariable @DateTimeFormat(iso = DATE_TIME)
				since: LocalDateTime
    )
     = messageRepository.findByTaskIdAndTimestampGreaterThan(
	  		taskId,
			since
	  )

}
\end{lstlisting}

{\textit{Controller}} nije ništa više nego sučelje prema repozitoriju koje je izloženo preko protokola HTTP. Konkretna mapiranja su definirana u anotacijama {\textit{PostMapping}} i {\textit{GetMapping}} koje deklariraju vezanje na HTTP metode POST i GET.

\hfill
\break

Metode koje su dostupne preko HTTP sučelja su:

\begin{enumerate}
\item Kreiranje novog unosa za dani zadatak i oznaku ({\textit{stdout}}, {\textit{stderr}} ili neka druga prikladna oznaka)
\item Dohvat unosa za dani zadatak
\item Dohvat unosa za dani zadatak koji su se dogodili nakon određenog trenutka u vremenu
\end{enumerate}

\subsection{Alat za pakiranje rješenja i ulaznih definicija u izvršne Docker slike}
\label{sec:packer}

Kako bi se moglo što izvoditi, potrebno je napraviti alat koji će pakirati ulazne definicije u izvršne Docker slike. Ova funkcionalnost ostvarena je u komandnolinijskom alatu {\textit{sandworm-packer}}, pisanom u programskom jeziku Kotlin.

Alat očekuje ulazne podatke u direktoriju oblika:

\begin{lstlisting}
source/
    main.c
    some_other_source_file.c
inputs/
    input description/
        stdin
        some_other_file
\end{lstlisting}

gdje je {\textit{source}} direktorij koji sadrži izvorni kod programa, a {\textit{inputs}} direktorij koji sadrži poddirektorije gdje svaki poddirektorij predstavlja jedan ulazni skup podataka. Datoteka {\textit{stdin}} u ulaznom skupu podataka bit će proslijeđena na standardni ulaz programa prilikom izvođenja, dok će sve ostale datoteke prisutne u tom direktoriju također biti prisutne i u direktoriju programa prilikom izvršavanja.

Sam alat podržava nekoliko opcija, a ispis svih može se dobiti pokretanjem programa bez argumenata:

\begin{lstlisting}
usage: packer
-b,--base-image <arg>       Define the base image to build upon
                            (e.g. sandworm/base/c_cpp)
-i,--task-id <arg>          A (preferably unique) ID of this task
                            run which will be passed to the
                            remote logger
-l,--logger-endpoint <arg>  The (optional) location of a remote
                            sandworm logger (e.g.
                            http://localhost:8080)
-p,--image-prefix <arg>     The tag prefix of the generated
                            images (e.g. sandworm/images/some_id)
-s,--source-directory <arg> The location from which to take the
                            source and the input files
\end{lstlisting}

Konkretno, program se poziva tako da mu se definira koju će temeljnu sliku koristiti (te time i programsko okruženje koje će biti dostupno prilikom izvođenja), identifikator zadatka koji će biti korišten prilikom zapisivanja informacija o pakiranju i prevođenju, lokaciju udaljene usluge za prikupljanje rezultata, prefiks naziva generiranih Docker slika te konačno direktorij u kojem se nalaze ulazne definicije na temelju kojih će se izgraditi pojedine izvršne slike. 

Samo ostvarenje oslanja se na nekoliko pomoćnih biblioteka. Za definiranje komandnolinijskog sučelja te učitavanje opcija korištena je biblioteka {\textit{Commons CLI}}{\footnote{\url{https://commons.apache.org/proper/commons-cli/}}}. Za komunikaciju s lokalnim Docker {\textit{daemonom}} (zbog izgradnje slika) korištena je biblioteka {\textit{docker-java}}{\footnote{\url{https://github.com/docker-java/docker-java}}}, dok je za komunikaciju s udaljenom uslugom za prikupljanje rezultata preko protokola HTTP korištena biblioteka {\textit{OkHttp}}{\footnote{\url{https://square.github.io/okhttp/}}}.

Alat je ostvaren u tri razreda. Pomoćni razred {\textit{RemoteLogger}} služi za komunikaciju s udaljenom uslugom za prikupljanje rezultata. Skripta {\textit{PackerCli}} služi kao ulazna točka u program i predstavlja definiciju komandnolinijskog sučelja. Konačno, razred {\textit{Packer}} sadrži algoritam za pakiranje ulaznih definicija u izvršne slike.

\subsubsection{Web sučelje prema alatu za pakiranje}

Kako bi bilo omogućeno jednostavnije korištenje napravljenog alata, oko njega je napravljen omotač koji za njega izlaže programsko sučelje preko protokola HTTP. On je također ostvaren pomoću programskog okvira {\textit{Spring}} te izlaže jednu krajnju točku koja preko POST zahtjeva prima ZIP datoteku koja sadrži ulaznu definiciju programa, lokaciju usluge za praćenje rezultata, naziv zadatka te naziv temeljne slike nad kojom će biti izgrađene izvršne slike. Kako je alat za pakiranje napravljen prvenstveno kao biblioteka koju koristi komandnolinijska aplikacija, implementiranje omotača svelo se na prosljeđivanje zahtjeva toj biblioteci. Cijeli omotač ostvaren je u jednom {\textit{Controlleru}} te Spring Boot pokretačkoj skripti. Ostvarenje {\textit{Controllera}} slijedi kako bi se prikazala jednostavnost korištenja ostvarene biblioteke:

\begin{lstlisting}
package hr.fer.zemris.sandworm.packer.web

import hr.fer.zemris.sandworm.packer.Packer
import hr.fer.zemris.sandworm.packer.RemoteLogger
import net.lingala.zip4j.core.ZipFile
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.multipart.MultipartFile
import java.nio.file.Files

@RestController
class MainController {

    @PostMapping("/")
    fun pack(
            @RequestParam file: MultipartFile,
            @RequestParam loggerEndpoint: String,
            @RequestParam taskId: String,
            @RequestParam baseImage: String
    ) {
        val outputDirectory = Files.createTempDirectory("packer").toFile()
        val temporaryFile = Files.createTempFile("packer", null).toFile()

        try {
            file.transferTo(temporaryFile)
            ZipFile(temporaryFile).extractAll(outputDirectory.absolutePath)

            Packer(RemoteLogger(taskId, loggerEndpoint)).pack(
                    outputDirectory,
                    baseImage,
                    taskId
            )
        } finally {
            outputDirectory.deleteRecursively()
            temporaryFile.delete()
        }
    }

}
\end{lstlisting}

\subsection{Usluga za zakazivanje izvođenja i upravljanje radilicama}

Samo izvođenje kreiranih slika ključan je dio sustava te predstavlja najboljeg kandidata za ostvarivanje svojstva razmjernog rasta. Zato je izvođenje ostvareno tako da sustav sadrži uslugu za zakazivanje izvođenja spojenu na nekoliko radilica koje odrađuju posao izvođenja. Zadaća sustava za zakazivanje izvođenja je primati zahtjeve za izvođenjem, pratiti stanja radilica te im dodjeljivati izvođenje jednom kada su radilice slobodne i spremne za rad.

Usluga je ostvarena kao web usluga u programskom okviru Spring koja nudi jednu krajnju točku - zakazivanje izvođenja koje kao parametar prima putanju do registra Docker slika u kojem se slika nalazi, naziv slike te putanju do usluge za praćenje izvođenja na koju će se slati informacije o izvođenju.

Nakon što zaprimi zahtjev, usluga ga prosljeđuje unutarnjoj usluzi {\textit{SchedulerService}}. Ta usluga unutar sebe prati stanje i zauzeće dostupnih radilica te, kada jedna postane slobodna, zakazuje zahtijevano izvođenje. Samo izvođenje svodi se na komuniciranje s Docker {\textit{daemonom}} prisutnim na radilici te slanjem instrukcija za povlačenje, a zatim i pokretanje odabrane slike. Definicija radilica prisutna je u privatnoj članskoj vrijednosti {\textit{availableClients}} u kojoj su zapisane putanje do Docker {\textit{daemona}} na radilicama.

Komuniciranje s Docker {\textit{daemonom}} na radilicama ostvareno je bibliotekom docker-java{\footnote{\url{https://github.com/docker-java/docker-java}}} koja omogućuje da se programski izvršavaju ekvivalenti naredbi {\textit{docker pull}} i {\textit{docker run}}.

Jednom kada je izvođenje završeno, radilica se vraća u bazen dostupnih radilica nakon čega je spremna obraditi novi zahtjev.

Svaki korak procesa zakazivanja izvođenja također se šalje na uslugu za praćenje izvođenja kako bi se moglo pratiti stanje izvođenja (zakazan / u izvođenju / gotov) pojedinog zadatka.

\subsubsection{Radilice}

Radilice koje izvršavaju programe najjednostavnija su komponenta sustava. Radi se o bilo kojem stroju (fizičkom ili virtualnom) koji ima instaliranu Docker okolinu te čiji je Docker {\textit{daemon}} dostupan usluzi za zakazivanje.

Radilicu je moguće napraviti tako da se na fizički stroj instalira okruženje Docker, ali također se mogu kreirati i koristeći sam Docker. Točnije, ako se pokrene slika {\textit{docker-in-docker}}{\footnote{\url{https://hub.docker.com/_/docker/}}}, dobiva se potpuno izolirano okruženje koje je spremno za korištenje kao radilica.

Radilica je ta koja izvršava program i šalje njegov ispis usluzi za prikupljanje rezultata izvođenja pa je također bitno da je ta usluga mrežno dostupna radilici.

\subsection{Dijeljeni registar Docker slika}
\label{sec:dockerregistry}

Konačno, kako bi se povezale usluga za pakiranje i usluga za izvršavanje slika, potrebno je među njima slike dijeliti. U tu svrhu je potreban dijeljeni registar Docker slika. Postoji mnogo ostvarenja Docker registara, a za potrebe testiranja odlučili za službeni {\textit{Docker Registry}}{\footnote{\url{https://docs.docker.com/registry/}}} koji je ujedno dostupan kao i Docker slika.

Službeni Docker registar je jednostavan za pokrenuti i koristiti, no mana mu je to što ne nudi mogućnost brisanja postojećih slika, što predstavlja problem u dužem korištenju jer je jedini način za čišćenje registra brisanje svih podataka i ponovno postavljanje onih koje se želi zadržati.

S druge strane, generirane Docker slike će zauzimati malo prostora - zbog slojevite arhitekture slika, svaka pojedina slika će zauzimati samo onoliko prostora koliko donosi nad svojom temeljnom slikom pa će tako prostor zauzimati samo prevedeni korisnički programi (jednom po programu) te korisnički programi vezani uz ulaznu definiciju, za svaku definiciju posebno. Ako su korisnički programi i ulazne definicije maleni (red veličine kB), što je slučaj sa studentskim vježbama, jeftinije je kupiti novi disk nego brinuti o zauzeću. No, unatoč tome potrebno je biti svjestan ovog problema, pogotovo ako se uzme u obzir da postoji mogućnost da se korisnički program maliciozno upakira u sliku koja je veća od očekivanog.

\chapter{Vrednovanje}

U nastavku je ostvareno rješenje vrednovano na temelju zahtjeva koji su bili postavljeni.

\section{Sigurnost}

Važna komponenta svakog sustava koji izvršava nepovjerljiv kod je sigurnost. Izvršavanjem programa prate se neprovjerene upute zadane od treće strane za koju se može pretpostaviti da će biti maliciozna. Samim time nužno je da ostvarenje sustava brine o sigurnosti i minimiziranju štete.

Samo izvršavanje programa vrši se unutar Docker {\textit{containera}}, izoliranih, samostalnih cjelina. Ovim cjelinama operativni sustav domaćin može ograničiti mrežne, procesne, memorijske i diskovne sposobnosti. Tako, neovisno o događajima unutar cjeline, na operativni sustav domaćin neće biti utjecaja. Najveća šteta koju maliciozni program u takvom kontekstu može napraviti je zauzeti veliku količinu diska ili se dugo izvršavati, što operativni sustav domaćin može detektirati i pritom zaustaviti cjelinu.

Ako zbog malicioznog programa dođe do prestanka radilice, postupak oporavka je jednostavan. Dovoljno je s radilice obrisati malicioznu cjelinu. Time će radilica biti vraćena u radno stanje i moći će nastaviti obrađivati zahtjeve. Dodatno, kako radilica, osim prisustva Docker okoline, ne zahtijeva dodatnu konfiguraciju, najlakši način oporavka radilice je ponovno provizioniranje iste.

Dodatnu sigurnost moguće je postići unošenjem izvršnih ograničenja, što je opisano u \ref{sec:runtimeconstraints} \nameref{sec:runtimeconstraints}.

\section{Razmjeran rast}

Drugo važno svojstvo modernog i učinkovitog sustava je mogućnost razmjernog rasta, tj. povećanje mogućnosti obrade dodavanjem novih strojeva ({\textit{horizontalni} rast).

Ovo svojstvo ostvareno je mikroservisnom arhitekturom u kojoj su sve komponente nezavisne cjeline, a komunikacija među njima je u potpunosti parametrizirana - primjerice, prilikom zakazivanja izvršavanja ujedno definiramo i lokaciju usluge za praćenje rezultata izvođenja. Posljedica takve arhitekture je da je moguće po volji dodavati i smanjivati broj inačica pojedine usluge čime se ujedno i linearno mijenjaju mogućnosti obrade cijelog sustava.

Samo izvršavanje programa, koje predstavlja najzahtjevniji dio sustava, izvodi se na radilicama spojenim u bazen. U taj bazen moguće je dodati proizvoljan broj radilica, ovisno o tome kako je poželjno optimirati vrijeme izvođenja u odnosu na troškove.

\section{Učinkovitost}

Zbog svojstva razmjernog rasta sustav je u mreži više računala učinkovitiji od izvođenja na jednom računalu. No, važno je razmotriti i rubni slučaj kada se sve cjeline pokreću na jednom sustavu te usporediti koliko je učinkovitosti izgubljeno te koje su mogućnosti dobivene zauzvrat.

\subsection{Vremenska učinkovitost}

Vremenska učinkovitost najviše stradava zbog troškova pakiranja programa u izvršne slike te pokretanja i zaustavljanja Docker cjelina prilikom izvršavanja programa. U općem slučaju će ti troškovi biti amortizirani trajanjem izvođenja samog programa.

Primjerice, trajanje prevođenja jednostavnog programa {\textit{Hello, World}} pisanog u programskom jeziku C traje ugrubo 0.2 sekunde.

\begin{lstlisting}
time gcc hello.c 
gcc hello.c  0,05s user 0,03s system 43% cpu 0,182 total
\end{lstlisting}

Izvršavanje samog programa gotovo je trenutno.

\begin{lstlisting}
echo "World" | time ./a.out
Hello, World!./a.out  0,00s user 0,00s system 0% cpu 0,003 total
\end{lstlisting}

S druge strane, pakiranje istog tog programa s dvije ulazne definicije dugotrajan je proces.

\begin{lstlisting}
time java -jar build/libs/packer-1.0-SNAPSHOT-all.jar \
  --base-image sandworm/base/c_cpp \
  --source-directory src/main/resources/c_sample \
  --image-prefix sandworm/images/test_image
(...)
packer/build/definition/hello petar :: Step 3/3 : RUN ./compile.sh
(...)
packer/build/definition :: Pushing image bd7c69e150b7
packer/build/definition :: Pushing image 9560392135d3
(...)
2,54s user 0,13s system 13% cpu 19,541 total
\end{lstlisting}

Samo izvršavanje Docker slike znatno je brže, ali i dalje je mnogo sporije od {\textit{sirovog}} izvršavanja na domaćinu

\begin{lstlisting}
time docker run --rm \
  sandworm/images/test_image/compiled/hello_world
Hello, world!
docker run --rm sandworm/images/test_image/compiled/hello_world
  0,03s user 0,01s system 1% cpu 3,012 total
\end{lstlisting}

Ako se pak makne zastavica {\textit{rm}} i time preskoči brisanje pokrenute slike nakon izvršavanja, dobiva se još bolji rezultat

\begin{lstlisting}
time docker run
  sandworm/images/test_image/compiled/hello_world 
Hello, world!
docker run sandworm/images/test_image/compiled/hello_world
  0,03s user 0,01s system 2% cpu 1,376 total
\end{lstlisting}

pa je jedna od mogućih optimizacija pokretanje programa bez zastavice {\textit{rm}} te periodično čišćenje radilice kada joj zauzeće padne.

Činjenica ostaje da pakiranje i pokretanje Dockerom unosi velike troškove koje je teško opravdati za male programe poput {\textit{Hello, World}}. S druge strane, kako su generirane slike neovisne o mjestu kreiranja i mjestu izvršavanja, mogu se kreirati bilo gdje i izvršiti bilo gdje, što omogućuje imanje više strojeva koji paralelno pakiraju i više strojeva koji paralelno izvršavaju slike, čime se može skratiti trajanje cijelog postupka. Dodatna prednost pristupa Dockerom je ta što slika predstavlja cjelinu s kojom je lako reproducirati rezultate izvođenja - za deterministični program izvođenje jednom pakirane slike će uvijek imati isti rezultat i isti ispis, što otvara mogućnost da student sam lokalno reproducira rezultat vrednovanja. Konačno, udio troškova Dockera bit će manji za programe čiji proces prevođenja i izvršavanja traje duže.

\subsection{Prostorna učinkovitost}

Svaka Docker slika u sebi sadrži cijelu okolinu operativnog sustava u kojem se program izvršava. Srećom, slike koje su izvedene iz istih temeljnih slika mogu tu temeljnu sliku dijeliti, čime je ukupan trošak slike smanjen.

Primjerice, za slike generirane za prijašnji primjer veličine su

\begin{lstlisting}
docker images --format="{{.Repository}} {{.Size}}" | grep sandworm
sandworm/images/test_image/compiled/hello_petar 325MB
sandworm/images/test_image/compiled/hello_world 325MB
sandworm/images/test_image/source 325MB
sandworm/base/c_cpp 325MB
sandworm/base/base 137MB
\end{lstlisting}

Vidljivo je da temeljna slika zauzima 137MB dok je dodavanje potpore za programske jezike C i C++ povećalo veličinu slike na 325MB. S druge strane, utjecaj prevođenja programa i dodavanje izvršnog konteksta nije vidljiv na razini MB.

Ukratko, pakiranje u slike je prostorno učinkovito jer svaki novi sloj iskorištava prostor dostupan u sloju iz kojeg je izveden. Za pristup bez Dockera bi prostorno zauzeće bilo slično jer bi bilo nužno instalirati isti skup potpornih programa za izvršavanje kao i u slikama {\textit{base}} i {\textit{c\_cpp}}.

\section{Jednostavnost korištenja}

Korisničko sučelje sustava ostvareno je kao skup jasno definiranih krajnjih točaka kojima se može pristupiti protokolom HTTP. Ovo omogućava korisniku da sustav koristi ručno ili da ostvari program koji će komunicirati sa sustavom. Iako je sustav složen za ručno korištenje, korištenjem dostupnog programskog sučelja moguće je automatizirati korištenje sustava kako bi isto bilo jednostavnije. Sam način korištenja opisan je u \ref{sec:usagemanual} \nameref{sec:usagemanual}.

\chapter{Daljnje dorade}

U nastavku su iznesene ideje koje bi bilo korisno razmotriti i implementirati kao proširenja postojećeg sustava.

\section{Vrednovanje ispisa programa}

Jedna od motivacija izgradnje ovog sustava bila je mogućnost zamjene SPRUT-a kao evaluacijskog mehanizma u kontekstu studentskih laboratorijskih vježbi.

Sustav koji je opisan trenutno podržava samo izvršavanje programa, ali ne i evaluaciju. Točnije, s trenutnim ostvarenjem ne postoji mogućnost automatskog vrednovanja rezultata izvođenja programskog rješenja.

Uzevši u obzir trenutnu arhitekturu sustava, vrednovanje ispisa moguće je ostvariti povlačenjem ispisa programa sa servisa za prikupljanje i skladištenje rezultata, filtriranjem istih po oznaci {\textit{stdout}} te uspoređivanjem dobivenog s očekivanim izlazom. Sam ispis može se dohvatiti na temelju oznake koja se dobije prilikom zakazivanja izvršavanja programa.

Dodatno, osim standardnog izlaza, ništa ne sprječava da se program vrednuje i po drugim zapisima - recimo, na temelju zapisa može se odrediti i je li bilo grešaka prilikom prevođenja te vrijeme koje je programu bilo potrebno da bi se izvršio.

Ukratko, trenutni sustav bilježi mnogo informacija na temelju kojih se može vrednovati ponašanje programa. Za izvedbu vrednovanja dovoljno je zakazati izvršavanje programa i zatim kasnije preuzeti informacije dostupne u servisu za prikupljanje i skladištenje rezultata.

\section{Unošenje izvršnih ograničenja}
\label{sec:runtimeconstraints}

Sustav trenutno nema potporu za definiranje izvršnih ograničenja (eng. {\textit{runtime constraints}}).

Izvršna ograničenja su korisna jer njima možemo dodatno ograničiti izvođenje zadajući, recimo, najviše dozvoljeno vrijeme izvođenja, najvišu dozvoljenu količinu iskorištene memorije ili najviše dozvoljen broj pokrenutih dretvi.

Izvršna ograničenja u postojećem sustavu mogu se ostvariti omatanjem skripte {\textit{runner.sh}} alatom {\textit{isolate}}\footnote{\url{https://github.com/ioi/isolate}}. {\textit{Isolate}} omogućuje definiranje raznih izvršnih ograničenja nad bilo kojim programom pa tako i programima koji se izvršavaju u sklopu ostvarenog sustava.

Za izvršna ograničenja bitno je napomenuti da primjena istih ovisi o okolini u kojoj se program izvršava. Primjerice, naivno ostvarenje ograničenja ukupne memorije bi ograničila količinu memorije koju proces može zauzeti i ubila ga ako on istu prijeđe. No, tehnologije zasnovane na sakupljačima smeća često ne pokreću proces oslobađanja memorije dok sami ne zaključe da je to potrebno.

Primjerice, ako značajno ograničimo količinu memorije za proces koji izvršava kod pisan u programskom jeziku Java, a pritom ne obavijestimo virtualni stroj o ograničenjima (za JVM to možemo napraviti zastavicom {\textit{Xmx}}) isti nikad neće pokrenuti proces sakupljanja smeća te će program brzo nasilno završiti, iako je pisani program ispravan te ne bi zauzeo previše memorije ako bi se proces sakupljanja smeća na vrijeme pokrenuo.

Uz samu potporu za zadavanje izvršnih ograničenja korisno bi bilo dodati i mogućnost definiranja istih kao dio ulazne definicije programa. Primjerice, jedna datoteka {\textit{constraints.yml}} pisana u formatu YAML\footnote{\url{https://en.wikipedia.org/wiki/YAML}} mogla bi sadržavati lako čitljivu definiciju svih ograničenja.Tu datoteku bi zatim upekli u sliku te pomoću nje prilikom pokretanja konstruirali parametre za poziv alata {\textit{isolate}}. Dodatno, na temelju nje bi morali izgraditi i potporu za ograničenja za pojedine tehnologije izvršavanja u njihovim odgovarajućim slikama kako bi izbjegli probleme poput onog sa sakupljanjem smeća navedenog prije.


\section{Korištenje Infrastruktura-kao-Usluga sustava za automatsko provizioniranje radilica}

Opisani sustav trenutno se oslanja na predefiniran set radilica zapisanih unutar servisa za zakazivanje izvođenja i upravljanje radilicama. Posljedica je da, neovisno o količini programa koje treba evaluirati u danom trenutku radilice uvijek moraju biti spremne i pokrenute.

Predviđeno opterećenje sustava u akademskim uvjetima je skokovito - postojat će dugi periodi kada se sustav neće koristiti te kratki periodi kada će biti potrebno vrednovati velik broj studentskih rješenja.

Kako će radilice biti potrebne samo kratko vrijeme, predlaže se da se sustav za upravljanje radilicama doradi tako da ih automatski provizionira kada je to potrebno te ugasi kada više nisu potrebne. Primjerice, ako se fizički strojevi koriste kao radilice, sustav za upravljanje može koristiti tehnologiju {\textit{Wake-on-LAN}}{\footnote{\url{https://en.wikipedia.org/wiki/Wake-on-LAN}} kako bi strojeve palio i gasio po potrebi i tako uštedio na troškovima energije.

No, kako je posljedica ostvarene arhitekture ta da uistinu nije bitno na čemu se izvršavaju programi, dokle god to nešto ima potporu za Docker, može se također osloniti i na Infrastruktura-kao-Usluga (eng. {\textit{Infrastructure-as-a-Service}}{\footnote{{\url{https://en.wikipedia.org/wiki/Cloud_computing}}}} sustave za automatsko provizioniranje radilica kada su potrebne te gašenje istih kada više nisu. Ovim pristupom može se ostvariti viša paralelizacija izvođenja te se mogu smanjiti troškovi jer takve usluge nude naplaćivanje po satu, što odgovara potrebama koje su opisane.

Tako je moguće imati samo jedan fizički stroj lokalno koji brine o zaprimanju zahtjeva, dok bi sav težak posao bio odrađen na dinamički provizioniranim radilicama.

Odabir ponuđača IaaS usluga ovisi ponajprije o cijeni te potrebama hardvera koji se zakupuje. Ponuđače koje vrijedi istaknuti su {\textit{DigitalOcean}}{\footnote{\url{https://www.digitalocean.com/}}}, {\textit{Amazon Web Services}}{\footnote{\url{https://aws.amazon.com/}}}, {\textit{Microsoft Azure}}{\footnote{\url{https://azure.microsoft.com/}}} te {\textit{Google Cloud Platform}}{\footnote{\url{https://cloud.google.com/}}}. DigitalOcean, primjerice, nudi provizioniranje sustava unutar 55 sekundi što je prihvatljivo vrijeme čekanja u odnosu na trajanje cijelog procesa vrednovanja.

Za ostvarenje ove ideje bilo bi potrebno prilagoditi sustav za zakazivanje izvođenja i upravljanje radilicama tako da, umjesto unaprijed definiranog niza radilica, koristeći programska sučelja odgovarajućeg ponuđača usluga kreira i uništava radilice po potrebi. Konkretno, za ponuđača usluga DigitalOcean može se iskoristiti biblioteka {\textit{digitalocean-api-java}}{\footnote{\url{https://github.com/jeevatkm/digitalocean-api-java}}}.

Po pitanju cijene i paralelizacije koja ovim pristupom možemo biti ostvarena, DigitalOcean u trenutku pisanja u svojoj ponudi, među ostalim, nudi i virtualne strojeve sa 512MB RAM, 20GB prostora za podatke te jednom virtualnom jezgrom što bi trebalo biti dovoljno za izvođenje studentskih vježbi. Cijena korištenja je \$0.007 po satu{\footnote{\url{https://www.digitalocean.com/pricing/}}} ili ugrubo 5 lipa po satu. Tako za trošak od kune po satu moguće je pokrenuti ugrubo dvadeset strojeva koji će paralelno izvršavati i vrednovati studentske programe, što je i više nego prihvatljivo za opisane potrebe.


\chapter{Zaključak}

Dano ostvarenje sustava zadovoljava sva svojstva koja su bila zadana na početku te je fleksibilno i proširivo na širok niz potreba. Arhitektura bazirana na izvršivim Docker slikama te mikroservisima koji ne dijele stanje omogućava sustavu da neometano razmjerno raste, dok je izvršavanje programa ostvareno pomoću radilica čije je provizioniranje jednostavno i brzo.

Pomoću tehnologije Docker također je ostvarena i sigurnost. Programska rješenja pokreću se u Docker okolinama koje su izolirane od ostatka sustava te program tako ne može naštetiti radilici na kojoj se izvršava.

Najbitnija značajka sustava je jednostavnost održavanja - dodavanje potpora za nova izvršna okruženja jednostavno je i neometano te se ne može dogoditi da jedno okruženje smeta drugome. Dodavanje radilica također je jednostavan proces jer je jedini zahtjev nad radilicom taj da ista pokreće Docker te da je hardverski sposobna izvršiti program koji ćemo joj proslijediti.

Mana sustava je neučinkovitost u izvršavanju programa s kratkim vremenom izvođenja zbog velikog troška pokretanja i gašenja Docker okolina, no to je trošak koji je moguće amortizirati programima koji se duže izvršavaju te iskorištavanjem većeg stupnja paralelizacije kojeg sustav nudi.

Ostvareni sustav tek je podloga za ostvarenje platforme za vrednovanje studentskih rješenja. Potrebno je još barem ostvariti mehanizam bodovanja izlaza programa te napraviti korisničko sučelje prema programu koje će automatizirati postupak stvaranja i pokretanja izvršivih slika te prikazivanja bitnih elemenata rezultata.

No, kao takvog, sustav je moguće iskoristiti kao izvršni sloj u već ostvarenim platformama kojima je potreban moderan, siguran i jednostavan izvršni sloj sa svojstvom razmjernog rasta.

\begin{appendices}

\chapter{Upute za postavljanje}

\section{Preuzimanje izvornog koda}

Izvorni kod cijelog sustava dostupan je na web sjedištu {\url{https://github.com/mrPjer/sandworm}} te je ostvaren kao nekoliko zasebnih potprojekata spojenih u jednu cjelinu.

Za preuzimanje svih potprojekata dovoljno je izvršiti naredbu

\begin{lstlisting}
git clone --recursive https://github.com/mrPjer/sandworm.git
\end{lstlisting}

čime će u direktorij {\textit{sandworm}} biti preuzeti svi potprojekti. U slučaju nedostupnosti prvog poslužitelja, projekt je zrcaljen na web sjedištu {\url{https://zr.psegina.com/sandworm.git}}.

Ostvarenje opisano u ovom radu označeno je u svakom potprojektu oznakom {\textit{zavrsni-rad}}.

\section{Instalacija temeljnih slika}
\label{sec:base-images}

Kako bi se mogle izgraditi izvršne Docker slike koje će pokretati programe, prvo je potrebno izgraditi i instalirati temeljne slike koje nude potporne programe i izvršne okoline potrebne za izvršavanje programa. Za tu potrebu dostupna je skripta {\textit{build.sh}} unutar potprojekta {\textit{sandworm-images}} koju je dovoljno pokrenuti da bi se izgradile slike za sve izvršne okoline.

\section{Usluga za prikupljanje i skladištenje rezultata}

Ova usluga je ostvarena pomoću programskog okvira Spring Boot koju se može pokrenuti lokalno na vratima 8001 pozicioniranjem u potprojekt {\textit{sandworm-logger}} i izvršavanjem naredbe

\begin{lstlisting}
SERVER_PORT=8081 ./gradlew bootRun
\end{lstlisting}

\section{Usluga za pakiranje rješenja i ulaznih definicija u izvršne Docker slike}

Ovaj usluga također je ostvarena pomoću programskog okvira Spring te se može pokrenuti lokalno na vratima 8002 pozicioniranjem u potprojekt {\textit{sandworm-packer-web}} i izvršavanjem naredbe

\begin{lstlisting}
SERVER_PORT=8082 ./gradlew bootRun
\end{lstlisting}

\section{Radilice}

Radilicu može predstavljati bilo kakav stroj, fizički ili virtualni, koji pokreće Docker te čiji je Docker {\textit{daemon}} dostupan preko mreže. Jednostavnosti radi, za testiranje se može pokrenuti nekolicina radilica pomoću samog alata Docker i slike {\textit{docker-in-docker}}{\footnote{\url{https://hub.docker.com/_/docker/}}}

\begin{lstlisting}
docker run --privileged \
	--name sandworm-worker-1 -d docker:17.05.0-ce-dind;
docker run --privileged \
	--name sandworm-worker-2 -d docker:17.05.0-ce-dind;
docker run --privileged \
	--name sandworm-worker-3 -d docker:17.05.0-ce-dind;
docker run --privileged \
	--name sandworm-worker-4 -d docker:17.05.0-ce-dind;
\end{lstlisting}

Za svaku kreiranu radilicu može se očitati IP adresa u lokalnoj virtualnoj mreži kako bi ih se moglo spojiti na uslugu za upravljanje radilicama

\begin{lstlisting}
docker inspect sandworm-worker-1 | grep IPAddress;
docker inspect sandworm-worker-2 | grep IPAddress;
docker inspect sandworm-worker-3 | grep IPAddress;
docker inspect sandworm-worker-4 | grep IPAddress;
\end{lstlisting}

\section{Usluga za zakazivanje izvođenja i upravljanje radilicama}

Nakon što su radilice kreirane i spremne za rad može se pokrenuti usluga za zakazivanje izvođenja i upravljanje radilicama. Nakon pozicioniranja u potprojekt {\textit{sandworm-scheduler}} prvi korak je otvoriti datoteku {\textit{./src/main/kotlin/hr/fer/zemris/sandworm/scheduler/service/SchedulerService.kt}} te u njoj prilagoditi polje {\textit{availableClients}} s adresama radilica dobivenim u prijašnjem koraku.

Izmijenjenu datoteku potrebno je spremiti te se usluga može pokrenuti na vratima 8003 naredbom

\begin{lstlisting}
SERVER_PORT=8083 ./gradlew bootRun
\end{lstlisting}

\section{Dijeljeni registar Docker slika}

Kako bi pojedine cjeline mogle dijeliti izvršne Docker slike među sobom potrebno je pokrenuti dijeljeni registar Docker slika koji je ranije opisan u poglavlju \ref{sec:dockerregistry} \nameref{sec:dockerregistry}.

\chapter{Upute za korištenje}
\label{sec:usagemanual}

U nastavku su opisani postupci korištenja sustava. Ove postupke može izvoditi čovjek, ali ih se preporuča automatizirati kao dio ostvarenja složenijeg sustava.

\section{Dodavanje potpore za nova izvršna okruženja}

Ostvarenje potpore za postojeća izvršna okruženja opisano je u poglavlju \ref{sec:implementation} \nameref{sec:implementation}.

Za dodavanje potpore za novo izvršno okruženje potrebno je stvoriti novu temeljnu sliku s instaliranom izvršnom okolinom tog okružtenja te ponuditi skriptu {\textit{runner.sh}} koja opisuje način pokretanja izvornog koda unutar te izvršne okoline. Ako je potrebno opisati i postupak prevođenja ili druge obrade koda prije samog izvršavanja, postupak za to nužno je dodati u skriptu {\textit{compile.sh}} unutar temelje slike projekta.

\subsection{Stvaranje nove temeljne slike s instaliranom izvršnom okolinom}

Projekt nudi temeljnu sliku {\textit{sandworm/base/base}} koja sadrži osnovne alate potrebne za rad sustava te je poželjno da slike s instaliranim izvršnim okolinama budu izvedene iz nje. U suprotnom, potrebno je ponovno ostvariti funkcionalnosti koje ta temeljna slika nudi, što je moguće proširenjem njene datoteke {\textit{Dockerfile}} dostupne u potprojektu {\textit{sandworm-images}}.

Pod pretpostavkom da je željena izvršna okolina dostupna na operativnom sustavu Ubuntu u paketu {\textit{izvrsna-okolina}}, za ostvarenje temeljne slike dovoljno je napraviti datoteku {\textit{Dockerfile}} sa sadržajem:

\begin{lstlisting}
FROM sandworm/base/base

RUN apt-get update \
    && apt-get install -y --no-install-recommends izvrsna-okolina \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

COPY runner.sh .
\end{lstlisting}

Naravno, po potrebi je ovu datoteku moguće proširiti i drugim naredbama koje će pripremiti izvršnu okolinu. Jedini uvjet je da je nakon izgradnje temeljne slike izvršna okolina u njoj dostupna i spremna za rad.

\subsection{Kreiranje skripte za izvršavanje, {\textit{runner.sh}}}

Idući korak je kreiranje skripte za izvršavanje koja sustavu govori kako pokrenuti rješenje u izvršnoj okolini. Pod pretpostavkom da se ulazna točka u izvorni kod nalazi u datoteci {\textit{main.skr}} te da ju izvršna okolina može pokrenuti naredbom {\textit{izvrsna-okolina main.skr}}, datoteka {\textit{runner.sh}} može biti ovog oblika:

\begin{lstlisting}
#!/usr/bin/env bash

izvrsna-okolina main.skr
\end{lstlisting}

\subsection{Opisivanje postupka prevođenja ili obrade koda}

Ako je izvorni kod prije samog izvršavanja potrebno prevesti ili na neki drugi način obraditi, potporu za to potrebno je dodati u skriptu {\textit{compile.sh}} temeljne slike {\textit{sandworm/base/base}}. Trenutni sadržaj te datoteke, s potporom za jezike C i C++ je:

\begin{lstlisting}
# Tries to compile with a compiler if it's present

type gcc >/dev/null && ls *.c >/dev/null 2>&1 && gcc *.c
type g++ >/dev/null && ls *.cpp >/dev/null 2>&1 && g++ *.cpp

exit 0
\end{lstlisting}

Skripta provjeri je li dostupna izvršna okolina u pitanju te nalaze li se u direktoriju datoteke koje ta okolina može prevesti. Ako su uvjeti međudjelovanje zadovoljeni, postupak prevođenja se provodi.

Na temelju ovog primjera moguće je dodati i potporu za prevođenjem proizvoljnih formata datoteka.

Bitno je napomenuti da, ako se ove izmjene rade u temeljnoj slici {\textit{sandworm/base/base}} da je istu potrebno ponovno izgraditi izvršavanjem skripte {\textit{build.sh}} u njenom direktoriju.

\subsection{Izgradnja napravljene temeljne slike}

Jednom kada je sve spremno, kako bi temeljnu sliku mogli koristiti, potrebno joj je dati ime, izgraditi ju i poslati ju na dijeljeni registar Docker slika. Pod pretpostavkom da ćemo sliku nazvati {\textit{sandworm/base/izvrsna-okolina}} te da se registar nalazi na domeni {\textit{registry.example.xyz}}, sliku možemo izgraditi i poslati na registar naredbama:

\begin{lstlisting}
docker build -t \
	registry.example.xyz/sandworm/base/izvrsna-okolina .;
docker push \
	registry.example.xyz/sandworm/base/izvrsna-okolina;
\end{lstlisting}

Nakon ovog koraka nova izvršna okolina spremna je za korištenje u sustavu i izvršavanje zadataka.

\section{Priprema ulazne definicije}

Prvi korak pri vrednovanju koda je priprema ulazne definicije koja sadrži izvorni kod i ulazne kontekste programa. Izvorni kod može biti proizvoljnog oblika te je jedini uvjet na njega da ga odabrana izvršna okolina može izvršiti. Poželjno je prije pakiranja provjeriti je li izvorni kod dobrog oblika (primjerice, je li ulazna točka definirana u dobroj datoteci) jer će u suprotnom ta greška postati vidljiva tek u procesu izvođenja. Ulazni kontekst programa može također biti proizvoljnog oblika te može sadržavati proizvoljne datoteke koje će programu biti dostupne prilikom izvođenja. Jedino ograničenje je to da će sadržaj datoteke {\textit{stdin}} biti prilikom izvršavanja proslijeđen na standardni ulaz programa.

Ulazna definicija je direktorij oblika:

\dirtree{%
.1 ..
	.2 inputs.
		.3 hello petar.
			.4 stdin.
		.3 hello world.
			.4 stdin.
	.2 source.
		.3 hello.c.
}

gdje svaki poddirektorij u direktoriju {\textit{inputs}} predstavlja jedan ulazni kontekst naziva istog kao i taj direktorij, dok direktorij {\textit{source}} sadrži izvorni kod programa. Tako dani primjer predstavlja ulaznu definiciju {\textit{Hello world!}} programa pisanog u programskom jeziku C koja ima dva ulazna primjera naziva {\textit{hello petar}} i {\textit{hello world}}.

\section{Pakiranje rješenja u izvršne Docker slike}

Kako bi se rješenje moglo izvršiti potrebno je ulaznu definiciju pretvoriti u niz izvršnih Docker slika gdje će svaka slika sadržavati izvršnu okolinu te izvorni kod združen s ulaznim kontekstom za danu ulaznu definiciju. Ta pretvorba može biti izvršena koristeći komandnolinijsku aplikaciju ili koristeći web uslugu za pakiranje.

Sam alat za pakiranje opisan je u poglavlju \ref{sec:packer} \nameref{sec:packer}.

\subsection{Pakiranje pomoću komandnolinijske aplikacije}

Slike je moguće generirati lokalno koristeći komandnolinijsku aplikaciju dostupnu u potprojektu {\textit{sandworm-packer}}. Prvo je potrebno prevesti aplikaciju koristeći naredbu

\begin{lstlisting}
./gradlew shadowJar
\end{lstlisting}

Nakon toga, pod pretpostavkama da je instalirana slika s potporom za izvršnu okolinu C (opisano u \ref{sec:base-images} \nameref{sec:base-images}), da se ulazna definicija nalazi u direktoriju {\textit{hello-world}} te da želimo da generirane slike imaju prefiks {\textit{sandworm/images/hello}}, izvršne slike možemo generirati naredbom

\begin{lstlisting}
java -jar build/libs/packer-1.0-SNAPSHOT-all.jar \
	--base-image sandworm/base/c_cpp \
	--source-directory hello-world \
	--image-prefix sandworm/images/hello
\end{lstlisting}

Ovaj postupak generirat će tri Docker slike - jednu sa spremnim prevedenim izvornim kodom te dvije koje na tu sliku još dodaju kontekst izvođenja. Nazivi generiranih slika bit će {\textit{prefiks}}/source za sliku s prevedenim kodom te {\textit{prefix}}/compiled/{\textit{naziv ulazne definicije}} za konačne izvršne slike.

Točnije, gornjim postupkom bit će generirane slike {\textit{sandworm/images/hello/source}}, {\textit{sandworm/images/hello/compiled/hello\_world}} i {\textit{sandworm/images/hello/compiled/hello\_petar}}.

Konačno, izvršavanje slike za primjer {\textit{hello world}}, moguće je učiniti naredbom

\begin{lstlisting}
docker run --rm -it sandworm/images/hello/compiled/hello_world;
\end{lstlisting}

Nakon što su slike izgrađene, poželjno je poslati ih na dijeljeni registar Docker slika kako bi im i druge komponente sustava mogle pristupiti.

\subsection{Pakiranje pomoću web usluge}

Uz pretpostavku da je web usluga za pakiranje pokrenuta i dostupna na adresi {\textit{packer.example.com}}, pakiranje se može izvršiti i putem protokola HTTP. Ovaj postupak također zahtijeva da je pokrenuta i dostupna i usluga za prikupljanje i skladištenje rezultata pa ćemo pretpostaviti da je dostupna na adresi {\textit{logger.example.com}} te da se zapisi žele ostvariti pod oznakom {\textit{hello-world}}.

Prvo je potrebno ulaznu definiciju pretvoriti u zip arhivu:

\begin{lstlisting}
cd hello-world;
zip -r definicija.zip .;
\end{lstlisting}

Zatim je tu definiciju potrebno poslati na web uslugu HTTP POST zahtjevom.

\begin{lstlisting}
curl --request POST \
  --url https://packer.example.com \
  --header 'content-type: multipart/form-data;' \
  --form file=@definicija.zip \
  --form loggerEndpoint=https://logger.example.com \
  --form 'taskId=hello-world' \
  --form 'baseImage=sandworm/base/c_cpp'
\end{lstlisting}

Nakon završetka ovog poziva, slike će biti izgrađene na jednak način kao i u postupku pakiranja sa komandnolinijskom aplikacijom.

\subsection{Slanje generiranih slika na dijeljeni registar Docker slika}

Kako bi radilice mogle pristupiti kreiranim slikama, potrebno ih je poslati na dijeljeni registar Docker slika. To je moguće učiniti ponovnim označavanjem svake slike, dodajući putanju do registra kao prefiks imenu slike. Recimo, za sliku {\textit{hello\_world}} iz prijašnjeg primjera, to je moguće učiniti naredbom

\begin{lstlisting}
docker tag \
  sandworm/images/hello/compiled/hello_world \
  registry.example.com/sandworm/images/hello/compiled/hello_world
\end{lstlisting}

Zatim ta ista slika može biti poslana na registar naredbom

\begin{lstlisting}
docker push \
  registry.example.com/sandworm/images/hello/compiled/hello_world
\end{lstlisting}

\section{Zakazivanje izvršavanja}

Pod pretpostavkom da je usluga za zakazivanje izvršavanja dostupna na domeni {\textit{scheduler.example.com}}, izvršavanje je sada moguće zakazati HTTP zahtjevom poslanog naredbom

\begin{lstlisting}
curl --request POST \
  --url https://scheduler.example.com/ \
  --header 'content-type: multipart/form-data;' \
  --form registryUrl=https://registry.example.com \
  --form \
image=registry.example.com/sandworm/images/hello/compiled/hello_world \
  --form loggingEndpoint=https://logger.example.com/run-hello-world
\end{lstlisting}

Informacije o izvršavanju će biti poslane na uslugu za praćenje i skladištenje rezultata izvršavanja pod oznakom {\textit{run-hello-world}}.

\section{Dohvat rezultata izvršavanja}

Konačno, dohvat rezultata izvršavanja moguće je napraviti HTTP zahtjevom na uslugu za praćenje i skladištenje rezultata izvršavanja. Dovoljno joj je, kao parametar, proslijediti oznaku izvršavanja koja nas zanima.

\begin{lstlisting}
curl --request GET \
  --url https://logger.example.com/scheduler-run
\end{lstlisting}

Rezultat će biti dobiven u strukturiranom JSON obliku.

\end{appendices}

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Rad daje osvrt na zahtjeve i tehničke poteškoće u ostvarivanju sustava za udaljeno izvođenje i vrednovanje studentskih programskih vježbi. Nakon kratkog pregleda postojećih rješenja, opisuje zahtjeve i značajke poželjnog sustava te nudi idejno rješenje koje zadovoljava te zahtjeve. Konačno, obrađuje konkretno rješenje ostvareno pomoću tehnologija Docker i Spring te opisuje način ostvarenja učinkovitog razmjernog rasta pomoću arhitekture bazirane na mikroservisima i izvršnim Docker slikama. Ostvareno rješenje ponuđeno je kao tehnologija otvorenog koda te se može iskoristiti u ostvarenju složenijih i zahtjevnijih sustava.

\kljucnerijeci{udaljeno izvođenje, studentske programske vježbe, siguran, učinkovit, razmjeran rast, mikroservisi, SPRUT, Docker, Kotlin, Spring}
\end{sazetak}

\engtitle{Secure and Scalable Remote Execution of Students' Programming Assignments}
\begin{abstract}
The paper gives an overview of the requirements and technical difficulties of an implementation of a system for remote execution and evaluation of students' programming assignments. After a brief overview of existing solutions, it describes the requirements and features of a desirable system and offers an idea of a solution that satisfies those requirements. Finally, it covers a concrete implementation based on Docker and Spring and describes an implementation of horizontal scalability based on a microservice architecture and executable Docker images. The implementation given is made available as open source and can be used as a building block for implementing more complex systems.

\keywords{remote execution, students' programming assignments, secure, efficient, scalable, horizontal scalability, microservices, SPRUT, Docker, Kotlin, Spring}
\end{abstract}

\end{document}
